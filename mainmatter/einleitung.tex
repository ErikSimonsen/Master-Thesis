\section{Einleitung}
\label{sec:einleitung}
In der folgenden Arbeit sind die ersten Vorkommen von Begriffen die möglicherweise nicht geläufig sind, aber
nicht im Fließtext erklärt werden, mit einem \verb|(*)| gekennzeichnet.
Diese Begriffe werden im Glossar und-/oder Acronymverzeichnis kurz erklärt.

\subsection{Problemstellung}
\label{subsec:problemstellung}
In den letzten Jahren sind die Anforderungen an Webanwendungen die zunehmende Digitalisierung und somit steigende Nutzerzahlen
sowie Architekturen die stark auf Client-Server-Kommunikation basieren, wie Microservices und \Glspl{spag}(*), erheblich gestiegen.

Während geschäftskritische Anwendungen lange Zeit mit ein paar Tausend Anfragen pro Sekunde als hoch frequentiert
galten, müssen solche Webanwendungen heutzutage jede Sekunde eine vielfach höhere Last bewältigen können.
Darüber hinaus müssen Sie \verb|skalierbar| sein, also ohne Performance-Einbussen in der Lage sein auf variable Lasten zu reagieren
und sich anzupassen.

Das Standardmodell für Java-basierte Webanwendungen ist das \verb|Thread per Request|-Modell.
Dabei wird jede HTTP-Anfrage an einen Kernel-Thread gebunden, welcher anschließend die Anfrage sequentiell abarbeitet.
Damit eine möglichst hohe Anzahl an Anfragen parallel abgearbeitet werden kann, wird jedem Thread nur ein Teil der verfügbaren
CPU-Rechenzeit eines CPU-Kerns zugewiesen. Sobald die Rechenzeit eines Threads abgelaufen ist, oder er durch einen blockierenden
Funktionsaufruf in einen inaktiven Zustand versetzt wird, wird der nächste Thread bearbeitet: es erfolgt ein \verb|Threadwechsel|.

Obwohl Threadwechsel, im Gegensatz zu Prozesswechseln, sehr kostengünstig sind, sind sie ab einer kritischen Anzahl HTTP-Anfragen
pro Sekunde der begrenzende Skalierungsfaktor. Die Threadwechsel zwischen den Kernelthreads des Betriebssystems erfolgen nicht mehr
schnell genug um jede Anfrage bzw. jeden Thread innerhalb einer akzeptablen Zeit zu bearbeiten.
Diese Begrenzung äußert sich letztendlich in nicht ausreichend skalierendem \Gls{durchsatz}(*) der Anwendung.

\subsection{Ziel der Arbeit}
\label{subsec:ziel}
Um höhere Workloads zu bewältigen und Anwendungen skalierbarer zu machen existieren alternative
Anwendungsmodelle, wie das in dieser Arbeit thematisierte \verb|Reactor-Pattern|.
Das Modell nutzt einen Thread pro CPU-Kern und verzichtet somit auf anwendungsbedingte Threadwechsel.
Die Voraussetzung dafür ist allerdings, dass die vorhandenen Threads niemals in einen inaktiven Zustand geraten bzw. blockieren,
weswegen Anfragen an externe Komponenten wie Datenbanken oder Webservices nicht imperativ sondern reaktiv ausgeführt werden
müssen: man spricht von \verb|reaktiver Programmierung|. Reaktive Programmierung erfordert das die gesamte Programmlogik jeder
Anwendungsschicht asynchron und eventbasiert strukturiert wird.
Nachdem eine Anfrage an eine externe Komponente abgesetzt wurde, beginnt der Thread bereits mit der Abarbeitung der nächsten
HTTP-Anfrage. Sobald ein Resultat verfügbar ist wird es dem Thread mithilfe eines Events mitgeteilt, welcher daraufhin
den, für dieses Event, hinterlegten Code weiter ausführt. Mit dieser grundlegenden Funktionsweise wird auf anwendungsbedingte
Threadwechsel verzichtet.

In dieser Arbeit wird untersucht, ob \verb|Reactive Programming| bzw. reaktive Anwendungen das Problem der Skalierbarkeit
für hohe Lasten praktikabel lösen können und welche alternativen Lösungsansätze es gibt.

\subsection{Vorgehensweise}
\label{subsec:vorgehensweise}
Um das Verhalten der beiden Modelle unter Last zu prüfen und miteinander zu vergleichen, werden zwei triviale Anwendungen,
reaktiv implementiert und nicht-reaktiv implementiert, einer Reihe von Lasttests mit unterschiedlichen \verb|workloads| unterzogen.
Dabei werden verschiedene \Glsplural{benchmark}(*), wie Durchsatz, Speicherbedarf und CPU-Auslastung gemessen.
Die Anwendungen werden sowohl als JVM-Anwendung, als auch als nativ ausführbare Anwendung jeweils mit Datenbankenanbindung und
ohne getestet.

\subsection{Aufbau}
\label{subsec:aufbau}
Zu Beginn der Arbeit werden in Kapitel \ref{sec:grundlagen} die Grundlagen der Thematik erläutert, also Kernel- und User-Threads,
blockierende und nicht-blockierende Eingabe-/Ausgabe-Operationen, sowie die beiden darauf aufbauenden Design-Patterns
\verb|Thread per Request| und \verb|Reactor|.

Anschließend werden in Kapitel \ref{section:reaktive_programmierung} die grundlegenden Konzepte von reaktiver Programmierung,
wie reaktive Datenströme, erklärt, sowie dessen Vor- und Nachteile genannt. Darauffolgend werden die Eigenschaften von reaktiven
Systemen und deren Beziehung untereinander beschrieben.
Danach wird auf die Unterstützung für reaktive Anwendungen und Architekturen innerhalb des Java Ökosystem, sowie Alternativen
eingegangen.

In Kapitel \ref{section:vergleich_reaktiv_blockierend} werden zuerst die Testumgebung definiert und der Testaufbau,
sowie der Testablauf beschrieben.
Im Anschluss werden die Testresultate, also die Messwerte, in Form von Diagrammen dargestellt und beschrieben.
Zuletzt erfolgt die Auswertung und Erläuterung der Testresultate.